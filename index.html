<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React RPG Engine: Chroma Key Edition</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #0f0f13; color: #e0e0e0; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        h1 { margin-bottom: 5px; color: #00e5ff; text-shadow: 0 0 10px rgba(0, 229, 255, 0.4); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { color: #888; font-size: 0.9rem; margin-bottom: 20px; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; width: 100%; max-width: 1300px; justify-content: center; }
        
        /* Card Styles */
        .card { background: #1a1a1f; padding: 25px; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.6); border: 1px solid #333; }
        
        /* Lab Panel */
        .lab-panel { flex: 1; min-width: 400px; display: flex; flex-direction: column; gap: 15px; }
        .input-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 0.75rem; color: #00e5ff; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        input[type="text"], select, textarea { 
            padding: 12px; border-radius: 6px; border: 1px solid #444; 
            background: #25252b; color: white; font-size: 0.9rem; outline: none; transition: 0.2s; font-family: 'Consolas', monospace;
        }
        input[type="text"]:focus, select:focus, textarea:focus { border-color: #00e5ff; background: #2f2f36; }
        textarea { resize: vertical; min-height: 60px; color: #a5f3fc; font-size: 0.8rem; line-height: 1.4; }

        .btn-row { display: flex; gap: 10px; }
        button { 
            flex: 1; padding: 12px; border-radius: 6px; border: none; cursor: pointer; 
            font-weight: bold; font-size: 1rem; transition: transform 0.1s; 
        }
        .btn-primary { background: linear-gradient(135deg, #00e5ff 0%, #0099cc 100%); color: #0f0f13; }
        .btn-secondary { background: #333; color: white; border: 1px solid #555; }
        .btn-magic { background: linear-gradient(135deg, #d53369 0%, #daae51 100%); color: white; }
        
        button:hover { filter: brightness(1.1); }
        button:disabled { background: #444; color: #888; cursor: not-allowed; filter: none; }

        /* Drop Zone Styles */
        .drop-zone { 
            margin-top: 15px; text-align: center; background: #000; padding: 15px; 
            border-radius: 8px; border: 2px dashed #444; position: relative; transition: 0.2s;
            overflow: hidden; display: flex; flex-direction: column; align-items: center;
        }
        .drop-zone.dragging { border-color: #00e5ff; background: #001a1f; }
        /* Checkerboard background to show transparency */
        .img-container {
            width: 100%; max-height: 300px; overflow: auto;
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .drop-zone img { width: 100%; object-fit: contain; display: block; }

        .drop-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.8); color: #00e5ff; font-weight: bold; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .drop-zone:hover .drop-overlay { opacity: 1; }

        /* World Panel */
        .world-panel { flex: 2; min-width: 340px; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; }
        canvas { background: #050505; border-radius: 8px; border: 2px solid #333; box-shadow: 0 0 40px rgba(0,0,0,0.5); image-rendering: pixelated; }
        .controls-hint { margin-top: 15px; color: #666; font-size: 0.8rem; text-align: center; }
        .controls-hint kbd { background: #333; padding: 2px 6px; border-radius: 4px; font-family: monospace; color: #00e5ff; }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

    // --- CONFIGURATION ---
    const TILE_SIZE = 64; 
    const MAP_COLS = 12;
    const MAP_ROWS = 9;
    
    // 0 = Grass, 1 = Rock (Collision)
    const WORLD_MAP = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    ];

    // --- HELPER: MOCK GENERATOR ---
    const generateMockSprite = (bitDepth, prompt) => {
        // Fallback SVG
        const colors = { "8": ["#e74c3c", "#c0392b"], "16": ["#3498db", "#2980b9"], "32": ["#9b59b6", "#8e44ad"], "64": ["#2ecc71", "#27ae60"], "128": ["#f1c40f", "#f39c12"], "256": ["#ffffff", "#bdc3c7"] };
        const c = colors[bitDepth] || colors["16"];
        
        // Note: Using a solid background here so the "Remove Background" feature has something to do
        const svg = `
        <svg width="600" height="600" xmlns="http://www.w3.org/2000/svg">
            <rect width="600" height="600" fill="#202020" />
            <circle cx="100" cy="100" r="40" fill="${c[0]}" stroke="white" stroke-width="5"/>
            <circle cx="300" cy="100" r="40" fill="${c[0]}" stroke="white" stroke-width="5" opacity="0.8"/>
            <circle cx="500" cy="100" r="40" fill="${c[0]}" stroke="white" stroke-width="5" opacity="0.6"/>
            
            <rect x="60" y="260" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5"/>
            <rect x="260" y="260" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5" opacity="0.8"/>
            <rect x="460" y="260" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5" opacity="0.6"/>

            <rect x="60" y="460" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5"/>
            <rect x="260" y="460" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5" opacity="0.8"/>
            <rect x="460" y="460" width="80" height="80" fill="${c[1]}" stroke="white" stroke-width="5" opacity="0.6"/>
            
            <text x="300" y="300" font-family="monospace" font-size="24" fill="white" text-anchor="middle">MOCK DATA</text>
        </svg>`;
        return "data:image/svg+xml;base64," + btoa(svg);
    };
     // --- SPRITE SLICING ---
        const getSpriteFrameCoords = (actionType, frameIndex) => {
            if (!imageObj) return { sx: 0, sy: 0, sWidth: 0, sHeight: 0 };
            
            const frameW = imageObj.width / 3;
            const frameH = imageObj.height / 3;
            
            let row = 0;
            if (actionType === 'idle') row = 0;
            if (actionType === 'walk_h') row = 1;
            if (actionType === 'walk_v') row = 2;
            
            return { 
                sx: frameIndex * frameW, 
                sy: row * frameH, 
                sWidth: frameW, 
                sHeight: frameH 
            };
        };
    // --- HELPER: BACKGROUND REMOVAL (MAGIC WAND) ---
    const removeBackground = (imageSrc) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = imageSrc;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // 1. Get the background color from the very first pixel (Top-Left)
                const bgR = data[0];
                const bgG = data[1];
                const bgB = data[2];
                // Tolerance allows for slight compression artifacts (JPG/Generation noise)
                const tolerance = 40; 

                // 2. Iterate over all pixels
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Calculate color distance
                    const dist = Math.sqrt(
                        (r - bgR) ** 2 +
                        (g - bgG) ** 2 +
                        (b - bgB) ** 2
                    );

                    // If color is close to background color, set Alpha to 0
                    if (dist < tolerance) {
                        data[i + 3] = 0; 
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL());
            };
            img.onerror = reject;
        });
    };

    const App = () => {
        // --- STATE ---
        const [prompt, setPrompt] = React.useState("A cyberpunk samurai with glowing armor");
        const [bitDepth, setBitDepth] = React.useState("256");
        const [apiKey, setApiKey] = React.useState("");
        const [isProcessing, setIsProcessing] = React.useState(false); // For Gen and BG removal
        const [generatedPrompt, setGeneratedPrompt] = React.useState(""); 
        const [spriteSheetUrl, setSpriteSheetUrl] = React.useState(generateMockSprite("256", ""));
        
        // Image & Game State
        const [imageObj, setImageObj] = React.useState(null);
        const [spriteDims, setSpriteDims] = React.useState({ w: 0, h: 0 }); 
        const [isDragging, setIsDragging] = React.useState(false);

        const canvasRef = React.useRef(null);
        const requestRef = React.useRef();
        const playerRef = React.useRef({
            x: 2 * TILE_SIZE, y: 2 * TILE_SIZE,
            speed: 4, direction: 'down', isMoving: false,
            frameIndex: 0, animationTimer: 0
        });
        const keysRef = React.useRef({});

        // --- FEATURE: PROMPT CONSTRUCTION ---
        const constructPrompt = () => {
            let stylePrompt = "";
            switch(bitDepth) {
                case "8": stylePrompt = "8-bit pixel art, NES style, flat colors"; break;
                case "16": stylePrompt = "16-bit pixel art, SNES style, vibrant colors"; break;
                case "32": stylePrompt = "32-bit ps1 style, pre-rendered 3d sprite"; break;
                case "64": stylePrompt = "64-bit N64 style, low poly texture"; break;
                case "128": stylePrompt = "128-bit PS2 style, smooth cel shaded"; break;
                case "256": stylePrompt = "256-bit modern high fidelity 4k sprite, highly detailed, octane render"; break;
                default: stylePrompt = "16-bit pixel art";
            }
            return `Create a sprite sheet for a character. The character is: ${prompt || "a hero"}. 
Style: ${stylePrompt}. 
Layout: 3x3 grid. 
Row 1: Idle animation (3 frames). 
Row 2: Walk horizontal side view (3 frames). 
Row 3: Walk vertical front view (3 frames).
Solid distinct background color (e.g. magenta or black) for easy removal.`;
        };

        const handleGenerate = async () => {
            setIsProcessing(true);
            const fullPrompt = constructPrompt();
            setGeneratedPrompt(fullPrompt);

            if (apiKey) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: fullPrompt }] }],
                            generationConfig: { response_mime_type: "image/png" }
                        })
                    });
                    const data = await response.json();
                    if (data.candidates && data.candidates[0].content.parts[0].inlineData) {
                         const base64Image = data.candidates[0].content.parts[0].inlineData.data;
                         setSpriteSheetUrl(`data:image/png;base64,${base64Image}`);
                    }
                } catch (error) {
                    console.error(error);
                    alert("API Error");
                }
                setIsProcessing(false);
                return;
            }

            // Mock Fallback
            setTimeout(() => {
                const newUrl = generateMockSprite(bitDepth, prompt);
                setSpriteSheetUrl(newUrl);
                setIsProcessing(false);
            }, 800);
        };

        // --- FEATURE: REMOVE BACKGROUND ---
        const handleRemoveBg = async () => {
            if (!imageObj) return;
            setIsProcessing(true);
            try {
                const cleanUrl = await removeBackground(spriteSheetUrl);
                setSpriteSheetUrl(cleanUrl); // Update state with transparent image
            } catch (e) {
                console.error("BG Removal failed", e);
            }
            setIsProcessing(false);
        };

        // --- FILE HANDLING ---
        const handleFile = (file) => {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                setSpriteSheetUrl(e.target.result);
                setGeneratedPrompt("Loaded: " + file.name);
            };
            reader.readAsDataURL(file);
        };
        const onDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
        const onDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
        const onDrop = (e) => { e.preventDefault(); setIsDragging(false); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); };

        // --- IMAGE LOADER ---
        React.useEffect(() => {
            const img = new Image();
            img.src = spriteSheetUrl;
            img.onload = () => {
                // Dynamic Sizing for 2816x1536
                const frameW = img.width / 3;
                const frameH = img.height / 3;
                setSpriteDims({ w: frameW, h: frameH });
                setImageObj(img);
            };
        }, [spriteSheetUrl]);

        // --- SPRITE SLICING ---
        const getSpriteFrameCoords = (actionType, frameIndex) => {
            const { w, h } = spriteDims;
            let row = 0;
            if (actionType === 'idle') row = 0;
            if (actionType === 'walk_h') row = 1;
            if (actionType === 'walk_v') row = 2;
            return { sx: frameIndex * w, sy: row * h, sWidth: w, sHeight: h };
        };

        // --- GAME LOOP ---
        React.useEffect(() => {
            const handleKey = (e, status) => { keysRef.current[e.key] = status; };
            window.addEventListener('keydown', e => handleKey(e, true));
            window.addEventListener('keyup', e => handleKey(e, false));
            return () => { window.removeEventListener('keydown', handleKey); window.removeEventListener('keyup', handleKey); };
        }, []);

        const update = () => {
            const player = playerRef.current;
            const keys = keysRef.current;
            let dx = 0, dy = 0;
            player.isMoving = false;

            if (keys['ArrowUp'] || keys['w']) { dy = -player.speed; player.direction = 'up'; player.isMoving = true; }
            if (keys['ArrowDown'] || keys['s']) { dy = player.speed; player.direction = 'down'; player.isMoving = true; }
            if (keys['ArrowLeft'] || keys['a']) { dx = -player.speed; player.direction = 'left'; player.isMoving = true; }
            if (keys['ArrowRight'] || keys['d']) { dx = player.speed; player.direction = 'right'; player.isMoving = true; }

            const nextX = player.x + dx + (TILE_SIZE/2);
            const nextY = player.y + dy + (TILE_SIZE/2);
            const gridX = Math.floor(nextX / TILE_SIZE);
            const gridY = Math.floor(nextY / TILE_SIZE);

            if (gridY >= 0 && gridY < MAP_ROWS && gridX >= 0 && gridX < MAP_COLS && WORLD_MAP[gridY][gridX] === 0) {
                player.x += dx; player.y += dy;
            }

            if (player.isMoving) {
                player.animationTimer++;
                if (player.animationTimer > 8) { 
                    player.frameIndex = (player.frameIndex + 1) % 3; 
                    player.animationTimer = 0; 
                }
            } else {
                player.animationTimer++;
                if (player.animationTimer > 20) {
                     player.frameIndex = (player.frameIndex + 1) % 3; 
                     player.animationTimer = 0; 
                }
            }
        };

        const draw = (ctx) => {
            ctx.fillStyle = '#121214';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            for (let r = 0; r < MAP_ROWS; r++) {
                for (let c = 0; c < MAP_COLS; c++) {
                    if (WORLD_MAP[r][c] === 1) {
                        ctx.fillStyle = '#444'; 
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.strokeStyle = '#222'; 
                        ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        ctx.fillStyle = (r+c)%2===0 ? '#263a26' : '#2d442d'; 
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            if (imageObj && spriteDims.w > 0) {
                const p = playerRef.current;
                let action = p.isMoving ? ( (p.direction==='left'||p.direction==='right') ? 'walk_h' : 'walk_v' ) : 'idle';
                
                const { sx, sy, sWidth, sHeight } = getSpriteFrameCoords(action, p.frameIndex);

                ctx.save();
                
                // --- ASPECT RATIO FIX FOR 2816x1536 ---
                // Frame is approx 938x512. TILE_SIZE is 64.
                // We want to scale Height to TILE_SIZE.
                const scaleFactor = TILE_SIZE / sHeight;
                const renderWidth = sWidth * scaleFactor;
                const renderHeight = TILE_SIZE; // sHeight * scaleFactor

                // Center width relative to tile position
                const xOffset = (TILE_SIZE - renderWidth) / 2;

                if (p.direction === 'left') {
                    // To flip correctly, we translate to the center of where the sprite should be
                    ctx.translate(p.x + (TILE_SIZE/2), p.y); 
                    ctx.scale(-1, 1);
                    // Draw centered at 0
                    ctx.drawImage(imageObj, sx, sy, sWidth, sHeight, -renderWidth/2, 0, renderWidth, renderHeight);
                } else {
                    ctx.drawImage(imageObj, sx, sy, sWidth, sHeight, p.x + xOffset, p.y, renderWidth, renderHeight);
                }
                ctx.restore();
            }
        };

        const tick = () => {
            update();
            if (canvasRef.current) draw(canvasRef.current.getContext('2d'));
            requestRef.current = requestAnimationFrame(tick);
        };

        React.useEffect(() => {
            requestRef.current = requestAnimationFrame(tick);
            return () => cancelAnimationFrame(requestRef.current);
        }, [imageObj, spriteDims]);

        return (
            <div className="container">
                <div style={{width: '100%', textAlign: 'center'}}>
                    <h1>React RPG Engine</h1>
                    <div className="subtitle">Resolution Independent • Background Removal • Nano Banana Pro</div>
                </div>
                
                <div className="card lab-panel">
                    <h2>Character Lab</h2>
                    
                    <div className="input-group">
                        <label>Google API Key (Optional)</label>
                        <input type="password" placeholder="Paste API Key here..." value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
                    </div>
                    <hr style={{borderColor: '#333', width: '100%'}} />

                    <div className="input-group">
                        <label>Character Prompt</label>
                        <input type="text" placeholder="e.g. A cyberpunk samurai" value={prompt} onChange={(e) => setPrompt(e.target.value)} />
                    </div>

                    <div className="input-group">
                        <label>Bit Depth (Style)</label>
                        <select value={bitDepth} onChange={(e) => setBitDepth(e.target.value)}>
                            <option value="64">64-bit (N64 Low Poly)</option>
                            <option value="128">128-bit (PS2/Xbox)</option>
                            <option value="256">256-bit (High Res 2816x1536)</option>
                        </select>
                    </div>

                    <div className="btn-row">
                        <button className="btn-primary" onClick={handleGenerate} disabled={isProcessing}>
                            {isProcessing ? "Processing..." : "Generate"}
                        </button>
                    </div>
                    
                    <div className="input-group">
                        <label>Generated Prompt (Copy-Paste)</label>
                        <textarea readOnly value={generatedPrompt} onClick={(e) => e.target.select()} placeholder="Prompt will appear here..."></textarea>
                    </div>
                    
                    <div 
                        className={`drop-zone ${isDragging ? 'dragging' : ''}`}
                        onDragOver={onDragOver}
                        onDragLeave={onDragLeave}
                        onDrop={onDrop}
                    >
                        <div className="drop-overlay">DROP SPRITE SHEET</div>
                        <div className="img-container">
                            {imageObj ? <img src={spriteSheetUrl} alt="Character Output" /> : <div style={{padding: '40px', color: '#666'}}>No Image Loaded</div>}
                        </div>
                        <div style={{marginTop: '10px', display:'flex', gap:'10px'}}>
                             <button className="btn-secondary" style={{fontSize:'0.8rem', padding:'6px'}} onClick={() => document.getElementById('fileInput').click()}>
                                Upload File
                            </button>
                             <button className="btn-magic" style={{fontSize:'0.8rem', padding:'6px'}} onClick={handleRemoveBg} disabled={isProcessing}>
                                ✨ Remove Background
                            </button>
                        </div>
                        <input type="file" id="fileInput" style={{display:'none'}} accept="image/*" onChange={(e) => handleFile(e.target.files[0])} />
                    </div>
                </div>

                <div className="card world-panel">
                    <h2>Game World</h2>
                    <canvas ref={canvasRef} width={MAP_COLS * TILE_SIZE} height={MAP_ROWS * TILE_SIZE} />
                    <div className="controls-hint">
                        <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> or Arrows to Move
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

</script>
</body>
</html>
